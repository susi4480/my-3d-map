# -*- coding: utf-8 -*-
"""
M5（自由空間外周ロフト） OBJ出力版
- 中心線生成（UKC→左右岸→中点→gap間引き→内挿）
- 各スライス: 帯抽出 → v–z占有（closing & anchor-downfill）→ 自由空間 free_bitmap
- free_bitmap(True=自由) の外周を抽出（cv2.findContours on free==255）
- 隣接スライスで外周ポリライン同士を重心距離で対応付け
- 同点数へ再サンプリングして四角面ストリップでロフト
- 出力: OBJ（メッシュのみ。マテリアルなし）

※M2の「左右壁」限定ではなく、M5の自由空間そのものの外周をメッシュでつなぐ。
"""

import os
import math
import numpy as np
import laspy
import cv2

# ===== 入出力 =====
INPUT_LAS  = r"/data/0731_suidoubasi_ue.las"
OUTPUT_OBJ = r"/output/0812_M5_free_outer_loft.obj"
os.makedirs(os.path.dirname(OUTPUT_OBJ) or ".", exist_ok=True)

# ===== パラメータ（中心線・断面）=====
UKC = -1.0                  # [m] 左右岸抽出に使う水面下閾値（中心線用）
BIN_X = 2.0                 # [m] 中心線作成時の X ビン幅
MIN_PTS_PER_XBIN = 50       # 各 X ビンに必要な最小点数
GAP_DIST = 50.0             # [m] 中心線候補の間引き距離
SECTION_INTERVAL = 0.5      # [m] 断面（中心線内挿）間隔
LINE_LENGTH = 60.0          # [m] 法線方向の全長（±半分使う）
SLICE_THICKNESS = 0.20      # [m] 接線方向の薄さ（u=±厚/2）
MIN_PTS_PER_SLICE = 80      # [点] 各帯の最低点数

# ===== 航行可能空間に使う高さ制限 =====
Z_MAX_FOR_NAV = 1.9         # [m] この高さ以下の点だけで航行空間を判定

# ===== v–z 断面のoccupancy =====
GRID_RES = 0.10             # [m/セル] v,z 解像度
MORPH_RADIUS = 23           # [セル] クロージング構造要素半径
USE_ANCHOR_DOWNFILL = True  # 水面高さ近傍で down-fill を有効化
ANCHOR_Z = 1.50             # [m] アンカー高さ（補間後の占有で判定）
ANCHOR_TOL = 0.50           # [m] 近傍幅（±）

# ===== ロフト対応付け =====
CONTOUR_RESAMPLE_DS = 0.10  # [m] 外周ポリライン再サンプル間隔
PAIR_MAX_CENTROID_DIST = 1.0  # [m] 隣接スライス外周の対応許容（重心距離）

# ===== 便利関数 =====
def l2(p, q):
    return math.hypot(q[0]-p[0], q[1]-p[1])

def resample_polyline(points_vz, ds):
    if len(points_vz) < 2: return points_vz
    P = np.asarray(points_vz, float)
    seg = np.linalg.norm(np.diff(P, axis=0), axis=1)
    s = np.concatenate([[0.0], np.cumsum(seg)])
    L = s[-1]
    if L < 1e-9: return P.tolist()
    n = max(2, int(np.ceil(L/ds)) + 1)
    si = np.linspace(0, L, n)
    out = []
    j = 0
    for t in si:
        while j+1 < len(s) and s[j+1] < t:
            j += 1
        if j+1 >= len(s): out.append(P[-1]); continue
        r = (t - s[j]) / max(1e-9, s[j+1]-s[j])
        out.append((1-r)*P[j] + r*P[j+1])
    return [p.tolist() for p in out]

def write_obj_mesh(path, vertices, faces):
    with open(path, "w", encoding="utf-8") as f:
        f.write("# OBJ generated by M5 free-space outer loft exporter\n")
        for v in vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")
        for face in faces:
            f.write("f " + " ".join(str(i) for i in face) + "\n")
    print(f"✅ OBJ出力: {path}  V={len(vertices)}  F={len(faces)}")

def find_max_rectangle(bitmap_bool: np.ndarray):
    """（未使用だが後で使いたい場合に残す）"""
    h, w = bitmap_bool.shape
    height = [0]*w
    best = (0, 0, 0, 0); max_area = 0
    for i in range(h):
        for j in range(w):
            height[j] = height[j] + 1 if bitmap_bool[i, j] else 0
        stack = []; j = 0
        while j <= w:
            cur = height[j] if j < w else 0
            if not stack or cur >= height[stack[-1]]:
                stack.append(j); j += 1
            else:
                top_idx = stack.pop()
                width = j if not stack else j - stack[-1] - 1
                area  = height[top_idx]*width
                if area > max_area:
                    max_area = area
                    top  = i - height[top_idx] + 1
                    left = (stack[-1] + 1) if stack else 0
                    best = (top, left, height[top_idx], width)
    return best

def downfill_on_closed(closed_uint8, z_min, grid_res, anchor_z, tol):
    """補間後の占有に対して、アンカー帯にヒットする列を下に埋める"""
    closed_bool = (closed_uint8 > 0)
    gh, gw = closed_bool.shape
    i_anchor = int(round((anchor_z - z_min) / grid_res))
    pad = max(0, int(np.ceil(tol / grid_res)))
    i_lo = max(0, i_anchor - pad)
    i_hi = min(gh - 1, i_anchor + pad)
    if i_lo > gh - 1 or i_hi < 0:
        return (closed_bool.astype(np.uint8) * 255)
    out = closed_bool.copy()
    for j in range(gw):
        col = closed_bool[:, j]
        if not np.any(col): continue
        if np.any(col[i_lo:i_hi+1]):
            imax = np.max(np.where(col)[0])
            out[:imax+1, j] = True
    return (out.astype(np.uint8) * 255)

def rectangles_and_free(points_vz, grid_res, morph_radius, use_anchor, anchor_z, anchor_tol):
    """
    v–z occupancyを作り、自由空間 free_bitmap（True=自由）とbboxを返す。
    """
    if len(points_vz) == 0:
        return None, None

    v_min, v_max = points_vz[:,0].min(), points_vz[:,0].max()
    z_min, z_max = points_vz[:,1].min(), points_vz[:,1].max()
    gw = max(1, int(np.ceil((v_max - v_min) / grid_res)))
    gh = max(1, int(np.ceil((z_max - z_min) / grid_res)))
    grid_raw = np.zeros((gh, gw), dtype=np.uint8)

    yi = ((points_vz[:,0] - v_min) / grid_res).astype(int)
    zi = ((points_vz[:,1] - z_min) / grid_res).astype(int)
    ok = (yi >= 0) & (yi < gw) & (zi >= 0) & (zi < gh)
    grid_raw[zi[ok], yi[ok]] = 255

    # closing & (optional) anchor down-fill
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2*morph_radius+1, 2*morph_radius+1))
    closed0 = cv2.morphologyEx(grid_raw, cv2.MORPH_CLOSE, kernel)
    closed  = downfill_on_closed(closed0, z_min, grid_res, anchor_z, anchor_tol) if use_anchor else closed0

    free_bitmap = ~(closed > 0)  # True=自由
    bbox = (v_min, z_min, gw, gh)
    return free_bitmap, bbox

def contours_from_free(free_bitmap, v_min, z_min, grid_res):
    """
    自由空間(True)の外周をポリラインとして抽出し、v–z座標列のリストを返す
    """
    if free_bitmap is None:
        return []
    img = np.zeros_like(free_bitmap, dtype=np.uint8)
    img[free_bitmap] = 255
    # 0/255画像で自由領域の外周を取得
    contours, _ = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    out = []
    for cnt in contours:
        pts = []
        for yx in cnt[:,0,:]:  # yx = [x(y列)=V, y(x行)=Z]
            x, y = int(yx[0]), int(yx[1])
            v = v_min + (x + 0.5)*grid_res
            z = z_min + (y + 0.5)*grid_res
            pts.append([v, z])
        if len(pts) >= 2:
            out.append(resample_polyline(pts, ds=CONTOUR_RESAMPLE_DS))
    return out

def vz_to_world_on_slice(vz, c, n_hat):
    """(v,z) -> 世界座標 (x,y,z)  ※u=0（帯の中心線上）"""
    v, z = vz
    p_xy = c + v * n_hat
    return [p_xy[0], p_xy[1], z]

# ===== メイン =====
def main():
    las = laspy.read(INPUT_LAS)

    # ndarray化
    X = np.asarray(las.x, float)
    Y = np.asarray(las.y, float)
    Z = np.asarray(las.z, float)
    xy  = np.column_stack([X, Y])

    # --- 中心線（UKCで左右岸→中点） ---
    x_min, x_max = xy[:,0].min(), xy[:,0].max()
    edges = np.arange(x_min, x_max + BIN_X, BIN_X)
    through = []
    for i in range(len(edges)-1):
        x0, x1 = edges[i], edges[i+1]
        m = (xy[:,0] >= x0) & (xy[:,0] < x1)
        if np.count_nonzero(m) < MIN_PTS_PER_XBIN:
            continue
        slab_xy = xy[m]; slab_z  = Z[m]
        order = np.argsort(slab_xy[:,1])
        slab_xy = slab_xy[order]; slab_z = slab_z[order]
        under = slab_z <= UKC
        if not np.any(under): continue
        idx = np.where(under)[0]
        left  = slab_xy[idx[0]]
        right = slab_xy[idx[-1]]
        c = 0.5*(left + right)
        through.append(c)
    if len(through) < 2:
        raise RuntimeError("中心線が作れません。UKCやBIN_Xを調整してください。")
    through = np.asarray(through, float)

    # --- gap=50mで間引き ---
    thinned = [through[0]]
    for p in through[1:]:
        if l2(thinned[-1], p) >= GAP_DIST:
            thinned.append(p)
    through = np.asarray(thinned, float)

    # --- 中心線を内挿（断面中心列） ---
    centers = []
    for i in range(len(through)-1):
        p, q = through[i], through[i+1]
        d = l2(p, q)
        if d < 1e-9: continue
        n_steps = int(d / SECTION_INTERVAL)
        for s_i in range(n_steps+1):
            s = min(s_i * SECTION_INTERVAL, d)
            t = s / d
            centers.append((1-t)*p + t*q)
    centers = np.asarray(centers, float)

    # --- 各スライス：free_bitmap（M5の基）と外周抽出 ---
    half_len = LINE_LENGTH * 0.5
    half_th  = SLICE_THICKNESS * 0.5

    slices = []  # per slice: {c, n_hat, contours_vz}
    for i in range(len(centers)-1):
        c  = centers[i]
        cn = centers[i+1]
        t_vec = cn - c
        norm = np.linalg.norm(t_vec)
        if norm < 1e-9:
            slices.append({"c": c, "n_hat": np.array([1.0,0.0]), "contours": []})
            continue
        t_hat = t_vec / norm
        n_hat = np.array([-t_hat[1], t_hat[0]], dtype=float)

        # 帯抽出
        dxy = xy - c
        u = dxy @ t_hat
        v = dxy @ n_hat
        m_band = (np.abs(u) <= half_th) & (np.abs(v) <= half_len)

        # 高さ制限
        m_nav = m_band & (Z <= Z_MAX_FOR_NAV)
        if np.count_nonzero(m_nav) < MIN_PTS_PER_SLICE:
            slices.append({"c": c, "n_hat": n_hat, "contours": []})
            continue

        points_vz = np.column_stack([v[m_nav], Z[m_nav]])
        free_bitmap, bbox = rectangles_and_free(
            points_vz, GRID_RES, MORPH_RADIUS, USE_ANCHOR_DOWNFILL, ANCHOR_Z, ANCHOR_TOL
        )
        if free_bitmap is None:
            slices.append({"c": c, "n_hat": n_hat, "contours": []})
            continue

        v_min, z_min, gw, gh = bbox
        conts = contours_from_free(free_bitmap, v_min, z_min, GRID_RES)
        slices.append({"c": c, "n_hat": n_hat, "contours": conts})

    # --- 隣接スライスで外周対応付け＆ロフト ---
    vertices = []
    faces    = []
    loft_strip_count = 0

    def pair_and_loft(contsA, cA, nA, contsB, cB, nB):
        nonlocal vertices, faces, loft_strip_count
        if not contsA or not contsB:
            return
        used = set()
        # 単純：重心距離最小で1:1
        def centroid(poly):
            P = np.asarray(poly); return P.mean(axis=0)
        for pa in contsA:
            ca = centroid(pa)
            best=None; best_d=1e9; idx=-1
            for j,pb in enumerate(contsB):
                if j in used: continue
                cb = centroid(pb)
                d = np.linalg.norm(ca - cb)
                if d < best_d:
                    best_d = d; best = pb; idx = j
            if best is None or best_d > PAIR_MAX_CENTROID_DIST:
                continue
            used.add(idx)

            # 等点数化
            P = np.asarray(resample_polyline(pa, ds=CONTOUR_RESAMPLE_DS))
            Q = np.asarray(resample_polyline(best, ds=CONTOUR_RESAMPLE_DS))
            n = min(len(P), len(Q))
            if n < 2: 
                continue
            P = P[:n]; Q = Q[:n]

            # 方向合わせ（zの昇降が一致するように）
            if (P[-1,1] - P[0,1]) * (Q[-1,1] - Q[0,1]) < 0:
                Q = Q[::-1].copy()

            # 頂点列（P→A面、Q→B面）
            Vp = [vz_to_world_on_slice(p, cA, nA) for p in P]
            Vq = [vz_to_world_on_slice(q, cB, nB) for q in Q]
            base = len(vertices)
            vertices.extend(Vp + Vq)

            # 四角面ストリップ (P_k, P_{k+1}, Q_{k+1}, Q_k)
            for k in range(n-1):
                i1 = base + (k + 1)
                i2 = base + (k + 2)
                j2 = base + (n + k + 2)
                j1 = base + (n + k + 1)
                faces.append([i1, i2, j2, j1])
                loft_strip_count += 1

    for i in range(len(slices)-1):
        A = slices[i]; B = slices[i+1]
        pair_and_loft(A["contours"], A["c"], A["n_hat"], B["contours"], B["c"], B["n_hat"])

    if not faces:
        raise RuntimeError("M5: 出力するロフトメッシュがありません。パラメータを見直してください。")

    write_obj_mesh(OUTPUT_OBJ, vertices, faces)
    print("✅ 完了: M5 自由空間外周ロフト OBJ")
    print(f"  スライス数: {len(centers)-1}")
    print(f"  生成ストリップ（四角面）: {loft_strip_count}")
    print(f"  頂点数: {len(vertices)} / 面数: {len(faces)}")

if __name__ == "__main__":
    main()
