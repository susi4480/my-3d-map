# -*- coding: utf-8 -*-
"""
M0+Loft（スライス内パネル + 隣接スライス接続） OBJ出力版
抽出ロジックは「アンカーdown-fill → クロージング → 自由空間から長方形詰め」に変更
"""

import os
import math
import numpy as np
import laspy
import cv2

# ===== 入出力 =====
INPUT_LAS  = r"/data/0731_suidoubasi_ue.las"
OUTPUT_OBJ = r"/output/0812no1_M0_with_loft_anchorFirst.obj"
os.makedirs(os.path.dirname(OUTPUT_OBJ) or ".", exist_ok=True)

# ===== パラメータ（中心線・断面）=====
UKC = -1.0
BIN_X = 2.0
MIN_PTS_PER_XBIN = 50
GAP_DIST = 50.0
SECTION_INTERVAL = 0.5
LINE_LENGTH = 60.0
SLICE_THICKNESS = 0.20
MIN_PTS_PER_SLICE = 80

# ===== 航行可能空間に使う高さ制限 =====
Z_MAX_FOR_NAV = 1.9

# ===== v–z 断面のoccupancy =====
GRID_RES = 0.10
MORPH_RADIUS = 23
USE_ANCHOR_DOWNFILL = True
ANCHOR_Z = 1.50
ANCHOR_TOL = 0.50
MIN_RECT_SIZE = 5

# （任意）主長方形から離れすぎた矩形は捨てる（m）。不要なら None
RECT_DIST_THRESHOLD = None  # 例: 5.0 にすると主矩形から5m超は除外

# ===== スライス間マッチ & ロフト =====
MATCH_CENTER_WEIGHT = 1.0
MATCH_SIZE_WEIGHT   = 0.5
MATCH_MAX_COST      = 1.5

# ===== 便利関数 =====
def l2(p, q):
    return math.hypot(q[0]-p[0], q[1]-p[1])

def order_corners_ccw(corners_vz, center_vz):
    c = np.asarray(center_vz)
    rel = np.asarray(corners_vz) - c
    ang = np.arctan2(rel[:,1], rel[:,0])
    idx = np.argsort(ang)
    return [corners_vz[i] for i in idx]

def write_obj_mesh(path, vertices, faces):
    with open(path, "w", encoding="utf-8") as f:
        f.write("# OBJ generated by M0+Loft (anchor-first) exporter\n")
        for v in vertices:
            f.write(f"v {v[0]:.6f} {v[1]:.6f} {v[2]:.6f}\n")
        for face in faces:
            f.write("f " + " ".join(str(i) for i in face) + "\n")
    print(f"✅ OBJ出力: {path}  V={len(vertices)}  F={len(faces)}")

def find_max_rectangle(bitmap_bool: np.ndarray):
    """True=自由 の2D配列（行=Z, 列=V）から最大内接長方形(top, left, h, w)"""
    h, w = bitmap_bool.shape
    height = [0]*w
    best = (0, 0, 0, 0); max_area = 0
    for i in range(h):
        for j in range(w):
            height[j] = height[j] + 1 if bitmap_bool[i, j] else 0
        stack = []; j = 0
        while j <= w:
            cur = height[j] if j < w else 0
            if not stack or cur >= height[stack[-1]]:
                stack.append(j); j += 1
            else:
                top_idx = stack.pop()
                width = j if not stack else j - stack[-1] - 1
                area  = height[top_idx]*width
                if area > max_area:
                    max_area = area
                    top  = i - height[top_idx] + 1
                    left = (stack[-1] + 1) if stack else 0
                    best = (top, left, height[top_idx], width)
    return best

def downfill_only_near_anchor(grid_uint8, z_min, grid_res, anchor_z=1.9, tol=0.15):
    """
    grid_uint8: 0/255（占有=255）, shape=(gh,gw) 行=Z, 列=V
    アンカー近傍に占有がある列のみ、その列を“上で見えた最上段”まで下方向に埋める
    """
    occ = (grid_uint8 > 0)
    gh, gw = occ.shape
    i_anchor = int(round((anchor_z - z_min) / grid_res))
    pad = max(0, int(np.ceil(tol / grid_res)))
    i_lo = max(0, i_anchor - pad)
    i_hi = min(gh - 1, i_anchor + pad)
    if i_lo > gh - 1 or i_hi < 0:
        return (occ.astype(np.uint8) * 255)

    for j in range(gw):
        col = occ[:, j]
        idx = np.where(col)[0]
        if idx.size == 0:
            continue
        if np.any((idx >= i_lo) & (idx <= i_hi)):
            imax = idx.max()
            col[:imax+1] = True
            occ[:, j] = col
    return (occ.astype(np.uint8) * 255)

def rectangles_on_slice_anchor_first(points_vz, grid_res, morph_radius,
                                     use_anchor, anchor_z, anchor_tol,
                                     min_rect_size, rect_dist_threshold=None):
    """
    ★今回の方式：アンカーdown-fill → クロージング → 自由空間から最大長方形を複数詰める
    返り: rect_models(list)
      rect = {center_vz, size_vw(=W,H), corners_vz[4]}
    """
    rect_models = []
    if len(points_vz) == 0:
        return rect_models

    v_min, v_max = points_vz[:,0].min(), points_vz[:,0].max()
    z_min, z_max = points_vz[:,1].min(), points_vz[:,1].max()
    gw = max(1, int(np.ceil((v_max - v_min) / grid_res)))
    gh = max(1, int(np.ceil((z_max - z_min) / grid_res)))
    grid_raw = np.zeros((gh, gw), dtype=np.uint8)

    yi = ((points_vz[:,0] - v_min) / grid_res).astype(int)
    zi = ((points_vz[:,1] - z_min) / grid_res).astype(int)
    ok = (yi >= 0) & (yi < gw) & (zi >= 0) & (zi < gh)
    grid_raw[zi[ok], yi[ok]] = 255  # 占有

    # 1) アンカー近傍 down-fill（先にやる）
    if use_anchor:
        grid1 = downfill_only_near_anchor(grid_raw, z_min, grid_res, anchor_z, anchor_tol)
    else:
        grid1 = grid_raw

    # 2) クロージング
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (2*morph_radius+1, 2*morph_radius+1))
    closed = cv2.morphologyEx(grid1, cv2.MORPH_CLOSE, kernel)

    # 3) 自由空間
    free_bitmap = (closed == 0)

    # 4) 自由空間に長方形を複数詰める（上方占有チェックなし）
    free_work = free_bitmap.copy()
    main_center = None
    while np.any(free_work):
        top, left, h, w = find_max_rectangle(free_work)
        if h < min_rect_size or w < min_rect_size:
            break

        # 矩形の中心（v,z）
        v0 = v_min + (left + 0.5) * grid_res
        z0 = z_min + (top  + 0.5) * grid_res
        W  = w * grid_res
        H  = h * grid_res

        # 主矩形からの距離制限（任意）
        if main_center is None:
            main_center = np.array([v0, z0], float)
        elif rect_dist_threshold is not None:
            if np.linalg.norm(np.array([v0, z0]) - main_center) > rect_dist_threshold:
                free_work[top:top+h, left:left+w] = False
                continue

        corners = [
            [v0,   z0   ],
            [v0+W, z0   ],
            [v0+W, z0+H ],
            [v0,   z0+H ],
        ]
        center = [v0 + 0.5*W, z0 + 0.5*H]
        corners = order_corners_ccw(corners, center)
        rect_models.append({
            "center_vz": np.array(center, dtype=float),
            "size_vw":   np.array([W, H], dtype=float),
            "corners_vz": [np.array(c, dtype=float) for c in corners],
        })

        # 使用済み領域を除外
        free_work[top:top+h, left:left+w] = False

    return rect_models

def vz_to_world_on_slice(vz, c, n_hat):
    """(v,z) -> 世界座標 (x,y,z)  ※u=0（帯の中心線上）"""
    v, z = vz
    p_xy = c + v * n_hat
    return [p_xy[0], p_xy[1], z]

# ===== メイン =====
def main():
    las = laspy.read(INPUT_LAS)

    # ndarray化
    X = np.asarray(las.x, float)
    Y = np.asarray(las.y, float)
    Z = np.asarray(las.z, float)
    xy = np.column_stack([X, Y])

    # --- 中心線（UKCで左右岸→中点） ---
    x_min, x_max = xy[:,0].min(), xy[:,0].max()
    edges = np.arange(x_min, x_max + BIN_X, BIN_X)
    through = []
    for i in range(len(edges)-1):
        x0, x1 = edges[i], edges[i+1]
        m = (xy[:,0] >= x0) & (xy[:,0] < x1)
        if np.count_nonzero(m) < MIN_PTS_PER_XBIN:
            continue
        slab_xy = xy[m]; slab_z = Z[m]
        order = np.argsort(slab_xy[:,1])
        slab_xy = slab_xy[order]; slab_z = slab_z[order]
        under = slab_z <= UKC
        if not np.any(under): continue
        idx = np.where(under)[0]
        left  = slab_xy[idx[0]]
        right = slab_xy[idx[-1]]
        c = 0.5*(left + right)
        through.append(c)
    if len(through) < 2:
        raise RuntimeError("中心線が作れません。UKCやBIN_Xを調整してください。")
    through = np.asarray(through, float)

    # --- gap=50mで間引き ---
    thinned = [through[0]]
    for p in through[1:]:
        if l2(thinned[-1], p) >= GAP_DIST:
            thinned.append(p)
    through = np.asarray(thinned, float)

    # --- 中心線を内挿（断面中心列） ---
    centers = []
    for i in range(len(through)-1):
        p, q = through[i], through[i+1]
        d = l2(p, q)
        if d < 1e-9: continue
        n_steps = int(d / SECTION_INTERVAL)
        for s_i in range(n_steps+1):
            s = min(s_i * SECTION_INTERVAL, d)
            t = s / d
            centers.append((1-t)*p + t*q)
    centers = np.asarray(centers, float)

    # --- スライス処理：各スライスの長方形モデルを保存 ---
    half_len = LINE_LENGTH * 0.5
    half_th  = SLICE_THICKNESS * 0.5
    slice_rects = []   # list[list[rect_model]]
    slice_frames = []  # list[(c, n_hat)]

    for i in range(len(centers)-1):
        c  = centers[i]
        cn = centers[i+1]
        t_vec = cn - c
        norm = np.linalg.norm(t_vec)
        if norm < 1e-9:
            slice_rects.append([])
            slice_frames.append((c, np.array([1.0,0.0])))
            continue
        t_hat = t_vec / norm
        n_hat = np.array([-t_hat[1], t_hat[0]], dtype=float)

        # 帯抽出
        dxy = xy - c
        u = dxy @ t_hat
        v = dxy @ n_hat
        m_band = (np.abs(u) <= half_th) & (np.abs(v) <= half_len)

        # 高さ制限（z≤Z_MAX_FOR_NAV）
        m_nav = m_band & (Z <= Z_MAX_FOR_NAV)
        if np.count_nonzero(m_nav) < MIN_PTS_PER_SLICE:
            slice_rects.append([])
            slice_frames.append((c, n_hat))
            continue

        points_vz = np.column_stack([v[m_nav], Z[m_nav]])

        # ★抽出ロジックをアンカー先行方式に差し替え
        rect_models = rectangles_on_slice_anchor_first(
            points_vz,
            grid_res=GRID_RES,
            morph_radius=MORPH_RADIUS,
            use_anchor=USE_ANCHOR_DOWNFILL,
            anchor_z=ANCHOR_Z,
            anchor_tol=ANCHOR_TOL,
            min_rect_size=MIN_RECT_SIZE,
            rect_dist_threshold=RECT_DIST_THRESHOLD
        )
        slice_rects.append(rect_models)
        slice_frames.append((c, n_hat))

    # ===== OBJ組み立て（スライス内パネル + スライス間ロフト） =====
    vertices = []
    faces = []

    def add_quad(v4_xyz):
        base = len(vertices) + 1
        vertices.extend(v4_xyz)
        faces.append([base, base+1, base+2, base+3])

    # 1) スライス内パネル（M0相当）
    panel_count = 0
    for s, rects in enumerate(slice_rects):
        c, n_hat = slice_frames[s]
        for rect in rects:
            corners_vz = order_corners_ccw([p.copy() for p in rect["corners_vz"]], rect["center_vz"])
            corners_xyz = [vz_to_world_on_slice(vz, c, n_hat) for vz in corners_vz]
            add_quad(corners_xyz)
            panel_count += 1

    # 2) 隣接スライス間ロフト（中心＋サイズのコストで対応）
    loft_count = 0
    for i in range(len(slice_rects)-1):
        A = slice_rects[i]
        B = slice_rects[i+1]
        if not A or not B:
            continue
        (cA, nA) = slice_frames[i]
        (cB, nB) = slice_frames[i+1]

        costs = []
        for ia, ra in enumerate(A):
            for ib, rb in enumerate(B):
                dc = np.linalg.norm(ra["center_vz"] - rb["center_vz"])
                ds = np.abs(ra["size_vw"] - rb["size_vw"]).sum()
                cst = MATCH_CENTER_WEIGHT*dc + MATCH_SIZE_WEIGHT*ds
                costs.append((cst, ia, ib))
        costs.sort(key=lambda x: x[0])

        usedA=set(); usedB=set(); pairs=[]
        for cst, ia, ib in costs:
            if cst > MATCH_MAX_COST:
                break
            if ia in usedA or ib in usedB:
                continue
            usedA.add(ia); usedB.add(ib); pairs.append((ia, ib))

        # ペアごとに4隅ロフト
        for ia, ib in pairs:
            Ra = A[ia]; Rb = B[ib]
            Ca = order_corners_ccw([c.copy() for c in Ra["corners_vz"]], Ra["center_vz"])
            Cb = order_corners_ccw([c.copy() for c in Rb["corners_vz"]], Rb["center_vz"])

            for k in range(4):
                ka = k
                kb = (k + 1) % 4
                quad_vz = [Ca[ka], Ca[kb], Cb[kb], Cb[ka]]
                quad_xyz = [vz_to_world_on_slice(vz, cA, nA) for vz in quad_vz[:2]] + \
                           [vz_to_world_on_slice(vz, cB, nB) for vz in quad_vz[2:]]
                add_quad(quad_xyz)
                loft_count += 1

    if not faces:
        raise RuntimeError("出力する面がありません。パラメータを見直してください。")

    write_obj_mesh(OUTPUT_OBJ, vertices, faces)
    print("✅ 完了: M0+Loft (anchor-first) OBJ")
    print(f"  スライス数: {len(centers)-1}")
    print(f"  スライス内パネル: {panel_count} 面")
    print(f"  スライス間ロフト側面: {loft_count} 面")
    print(f"  頂点数: {len(vertices)} / 面数: {len(faces)}")

if __name__ == "__main__":
    main()
